package com.delivery.delivery_service.repository;

import com.delivery.delivery_service.entity.AgentEntity;
import com.delivery.delivery_service.entity.AgentStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.transaction.annotation.Transactional; // Import Transactional

import java.util.List; // Import List
import java.util.Optional; // Import Optional

import static org.junit.jupiter.api.Assertions.*; // Static imports for assertion methods

/**
 * Integration tests for the {@link AgentRepository}.
 * This class uses {@code @DataJpaTest} to test JPA repositories.
 * It provides a dedicated testing slice of the Spring context, focusing only on JPA components.
 * <p>
 * {@code @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)}
 * is used to prevent Spring Boot from replacing your configured database (e.g., MySQL, PostgreSQL)
 * with an in-memory H2 database, allowing tests against a real database instance.
 * If you prefer an in-memory database for faster tests, you can remove this annotation.
 * </p>
 * <p>
 * This test suite ensures that the `AgentRepository` properly interacts with the database
 * for CRUD (Create, Read, Update, Delete) operations and custom queries.
 * </p>
 */
@DataJpaTest // Configures Spring Boot for JPA slice testing
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) // Use actual database, not in-memory
public class DeliveryRepositoryTest { // Class name implies DeliveryRepository, but tests AgentRepository

    /**
     * The repository under test. Spring will inject an instance of `AgentRepository`.
     */
    @Autowired
    private AgentRepository agentRepository;

    /**
     * {@link TestEntityManager} provides a subset of `EntityManager` methods
     * designed for tests. It allows for direct database operations (persist, find, remove, flush, clear)
     * which are useful for setting up test data and verifying results outside of repository methods.
     */
    @Autowired
    private TestEntityManager entityManager;

    // AgentEntity instances used across multiple tests.
    // Declared here to be initialized in setUp() and used in test methods.
    private AgentEntity agentAlice;
    private AgentEntity agentBob;

    /**
     * Sets up the test environment before each test method execution.
     * Ensures test isolation by clearing the database and populating it with fresh test data.
     * {@code @Transactional} ensures that the setup operations are atomic and can be rolled back
     * if the test itself is transactional (which `DataJpaTest` makes them by default).
     */
    @BeforeEach
    @Transactional // Essential for ensuring cleanup operations and data setup are transactional
    void setUp() {
        // 1. Clear existing data to ensure test isolation.
        // This is crucial when testing against a real database to avoid test interference.
        // Using `executeUpdate()` with JPQL for efficient bulk deletion.
        entityManager.getEntityManager().createQuery("DELETE FROM AgentEntity").executeUpdate();
        // Clear the persistence context after deletion to ensure subsequent reads hit the database.
        entityManager.clear();

        // 2. Initialize fresh AgentEntity objects for the current test.
        // IDs are NOT set manually; they will be generated by the database upon persistence.
        agentAlice = AgentEntity.builder()
                .agentName("Alice Smith")
                .agentStatus(AgentStatus.AVAILABLE)
                .agentPhoneNumber("1112223333")
                .build();

        agentBob = AgentEntity.builder()
                .agentName("Bob Johnson")
                .agentStatus(AgentStatus.ASSIGNED)
                .agentPhoneNumber("4445556666")
                .build();

        // 3. Persist the entities to the in-memory database or configured database.
        // `persistAndFlush()` saves entities and immediately flushes them to the database,
        // making their generated IDs available and ensuring they are visible for subsequent queries.
        entityManager.persistAndFlush(agentAlice);
        entityManager.persistAndFlush(agentBob);

        // 4. Clear the persistence context again.
        // This ensures that any `findById` or `findAll` calls in the actual test method
        // will retrieve data directly from the database, rather than from the JPA cache.
        entityManager.clear();
    }

    /**
     * Tests the `findById` method of {@link AgentRepository} for a successful lookup.
     * Verifies that an existing agent can be retrieved by its ID and its properties match.
     */
    @Test
    @DisplayName("Should find an agent by ID")
    void findById_Success() {
        // Retrieve an agent using its ID, which was populated during setUp()
        Optional<AgentEntity> foundAgent = agentRepository.findById(agentAlice.getAgentId());

        // Assertions to verify the presence and correctness of the retrieved agent
        assertTrue(foundAgent.isPresent(), "Agent should be found by ID");
        assertEquals(agentAlice.getAgentName(), foundAgent.get().getAgentName(), "Agent name should match");
        assertEquals(agentAlice.getAgentStatus(), foundAgent.get().getAgentStatus(), "Agent status should match");
        assertEquals(agentAlice.getAgentPhoneNumber(), foundAgent.get().getAgentPhoneNumber(), "Agent phone number should match");
    }

    /**
     * Tests the `findById` method for a non-existent agent ID.
     * Verifies that no agent is returned in this case.
     */
    @Test
    @DisplayName("Should not find an agent by non-existent ID")
    void findById_NotFound() {
        // Attempt to find an agent using an ID that is not in the database
        Optional<AgentEntity> foundAgent = agentRepository.findById(9999L); // Using a clearly non-existent ID
        assertFalse(foundAgent.isPresent(), "Agent should not be found for a non-existent ID");
    }

    /**
     * Tests the `save` method of {@link AgentRepository} for creating a new agent.
     * Verifies that a new agent can be persisted, receives an ID, and can be retrieved.
     */
    @Test
    @DisplayName("Should save a new agent")
    void saveAgent() {
        // Create a new AgentEntity that is not yet in the database
        AgentEntity newAgent = AgentEntity.builder()
                .agentName("Charlie Brown")
                .agentStatus(AgentStatus.AVAILABLE)
                .agentPhoneNumber("7778889999")
                .build();

        // Save the new agent using the repository
        AgentEntity savedAgent = agentRepository.save(newAgent);
        entityManager.flush(); // Ensure the save operation is committed to the database
        entityManager.clear(); // Clear context to force retrieval from DB

        // Assert that the saved agent has received a generated ID
        assertNotNull(savedAgent.getAgentId(), "Saved agent should have an ID");
        assertEquals("Charlie Brown", savedAgent.getAgentName(), "Saved agent name should match");

        // Verify the newly saved agent can be retrieved from the database
        Optional<AgentEntity> retrievedAgentOpt = agentRepository.findById(savedAgent.getAgentId());
        assertTrue(retrievedAgentOpt.isPresent(), "Newly saved agent should be retrievable");

        AgentEntity retrievedAgent = retrievedAgentOpt.get();
        // Assert that the retrieved agent's properties match the saved agent's properties
        assertEquals(savedAgent.getAgentId(), retrievedAgent.getAgentId(), "Retrieved agent ID should match saved agent ID");
        assertEquals(savedAgent.getAgentName(), retrievedAgent.getAgentName(), "Retrieved agent name should match saved agent name");
        assertEquals(savedAgent.getAgentStatus(), retrievedAgent.getAgentStatus(), "Retrieved agent status should match saved agent status");
        assertEquals(savedAgent.getAgentPhoneNumber(), retrievedAgent.getAgentPhoneNumber(), "Retrieved agent phone number should match saved agent phone number");
    }

    /**
     * Tests updating an existing agent's status using the `save` method.
     * Verifies that the status changes are persisted correctly.
     */
    @Test
    @DisplayName("Should update an existing agent's status")
    void updateAgentStatus() {
        // Retrieve the agent created in setUp() using the repository
        Optional<AgentEntity> initialAgentOpt = agentRepository.findById(agentAlice.getAgentId());
        assertTrue(initialAgentOpt.isPresent(), "Agent to update should exist");
        AgentEntity agentToUpdate = initialAgentOpt.get();
        assertEquals(AgentStatus.AVAILABLE, agentToUpdate.getAgentStatus(), "Initial status should be AVAILABLE");

        // Modify the agent's status
        agentToUpdate.setAgentStatus(AgentStatus.ASSIGNED);
        // Save the modified agent (JPA handles update if ID exists)
        AgentEntity updatedAgent = agentRepository.save(agentToUpdate);
        entityManager.flush(); // Commit changes
        entityManager.clear(); // Clear context

        // Assert that the returned updated agent has the new status
        assertEquals(AgentStatus.ASSIGNED, updatedAgent.getAgentStatus(), "Updated agent status should be ASSIGNED");
        assertEquals(agentToUpdate.getAgentId(), updatedAgent.getAgentId(), "Updated agent ID should remain the same");

        // Verify the update by fetching the agent directly from the database
        Optional<AgentEntity> retrievedAgentOpt = agentRepository.findById(agentAlice.getAgentId());
        assertTrue(retrievedAgentOpt.isPresent(), "Agent should still be present after update");
        assertEquals(AgentStatus.ASSIGNED, retrievedAgentOpt.get().getAgentStatus(), "Retrieved agent status should be ASSIGNED after update");
    }

    /**
     * Tests the `deleteById` method of {@link AgentRepository}.
     * Verifies that an agent can be successfully removed from the database.
     */
    @Test
    @DisplayName("Should delete an agent by ID")
    void deleteAgent() {
        // Ensure the agent exists before starting the delete operation
        Optional<AgentEntity> agentBeforeDelete = agentRepository.findById(agentAlice.getAgentId());
        assertTrue(agentBeforeDelete.isPresent(), "Agent should exist before deletion");

        // Perform the delete operation
        agentRepository.deleteById(agentAlice.getAgentId());
        entityManager.flush(); // Commit changes to the database
        entityManager.clear(); // Clear context

        // Verify that the deleted agent can no longer be found
        Optional<AgentEntity> deletedAgent = agentRepository.findById(agentAlice.getAgentId());
        assertFalse(deletedAgent.isPresent(), "Agent should not be found after deletion");

        // Verify that other data (agentBob) remains untouched
        long remainingAgentsCount = agentRepository.count();
        assertEquals(1, remainingAgentsCount, "Only one agent (agentBob) should remain after deletion");
    }

    /**
     * Tests the `findAll` method of {@link AgentRepository}.
     * Verifies that all agents present in the database are retrieved.
     */
    @Test
    @DisplayName("Should find all agents")
    void findAllAgents() {
        // In setUp(), two agents (Alice and Bob) are persisted.
        List<AgentEntity> allAgents = agentRepository.findAll();

        // Assertions to verify the list is not null and contains the expected number of agents
        assertNotNull(allAgents, "List of agents should not be null");
        assertEquals(2, allAgents.size(), "Should find exactly 2 agents after setup");

        // Assert that the specific agents persisted in setUp are indeed in the retrieved list
        assertTrue(allAgents.stream().anyMatch(a -> a.getAgentId().equals(agentAlice.getAgentId()) && a.getAgentName().equals(agentAlice.getAgentName())),
                "Alice should be in the list");
        assertTrue(allAgents.stream().anyMatch(a -> a.getAgentId().equals(agentBob.getAgentId()) && a.getAgentName().equals(agentBob.getAgentName())),
                "Bob should be in the list");
    }

    /**
     * Tests a custom query method `findByAgentStatus` for agents with `AVAILABLE` status.
     * This test assumes `AgentRepository` has a method like `List<AgentEntity> findByAgentStatus(AgentStatus status);`.
     */
    @Test
    @DisplayName("Should find agents by status (AVAILABLE)")
    void findByAgentStatus_Available() {
        // Alice is AVAILABLE from setUp()
        List<AgentEntity> availableAgents = agentRepository.findByAgentStatus(AgentStatus.AVAILABLE);

        assertNotNull(availableAgents);
        assertEquals(1, availableAgents.size(), "Should find 1 available agent (Alice)");
        assertEquals(agentAlice.getAgentName(), availableAgents.get(0).getAgentName());
        assertEquals(AgentStatus.AVAILABLE, availableAgents.get(0).getAgentStatus());
    }

    /**
     * Tests a custom query method `findByAgentStatus` for agents with `ASSIGNED` status.
     * This test assumes `AgentRepository` has a method like `List<AgentEntity> findByAgentStatus(AgentStatus status);`.
     */
    @Test
    @DisplayName("Should find agents by status (ASSIGNED)")
    void findByAgentStatus_Assigned() {
        // Bob is ASSIGNED from setUp()
        List<AgentEntity> assignedAgents = agentRepository.findByAgentStatus(AgentStatus.ASSIGNED);

        assertNotNull(assignedAgents);
        assertEquals(1, assignedAgents.size(), "Should find 1 assigned agent (Bob)");
        assertEquals(agentBob.getAgentName(), assignedAgents.get(0).getAgentName());
        assertEquals(AgentStatus.ASSIGNED, assignedAgents.get(0).getAgentStatus());
    }
}